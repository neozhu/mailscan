@using Services.JsInterop
@using Services

@implements IAsyncDisposable

@inject IJSRuntime JS

<MudCard Style="@($"width:{innerWidth}px")">
    <div class="mud-card-media video-container" style="@($"position: relative;width:{innerWidth}px;height:280px")">
        <video id="video" @ref=VideoElement autoplay playsinline style="@($"width:{innerWidth}px;height:273px;object-fit: cover;")">
            @if (errorMessage is not null)
            {
                <div class="alert alert-danger">
                    @errorMessage
                </div>
            }
        </video>
        @if (processing)
        {
            <div class="blur-overlay" style="position: absolute; top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.5); /* 透明度可以调整 */
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);"></div>
        }
    </div>
    <MudCardActions Class="justify-space-between">
        <MudLoadingButton Loading="@processing" StartIcon="@Icons.Material.Filled.DocumentScanner" Variant="Variant.Filled" Disabled="@(!isCameraStreaming)" OnClick="Scan" Color="Color.Primary">Scan</MudLoadingButton>
        <MudButton   Variant="Variant.Filled" Color="Color.Secondary" StartIcon="@Icons.Material.Filled.Clear" OnClick="@(()=>Histories.Clear())"  >Clear</MudButton>
    </MudCardActions>
     <MudCardContent Class="ma-0 pa-0">
        
         <MudList>
            @if (processing)
            {
                <MudListItem>
                    <MudPaper Class="pa-5">
                <MudSkeleton Height="30px" />
                <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="40px" />
                    </MudPaper>
                </MudListItem>
            }
            @foreach (var item in Histories)
            {
                <MudListItem>
                    <MudPaper Class="pa-5">
                        <MudText Typo="Typo.h6">Name: @item.Entities.Persons?.FirstOrDefault()</MudText>
                        <MudText Class="">Department: @item.Entities.Organizations?.FirstOrDefault()</MudText>
                        <MudText>Address: @item.Entities.Locations?.First()</MudText>
                    </MudPaper>
                </MudListItem>
            }
         </MudList>
     </MudCardContent>
    <MudCardContent>
        
        

    </MudCardContent>
    <MudCardMedia Image="@imageDataURL"></MudCardMedia>
</MudCard>

@code {
    private int innerWidth = 390;
    private ElementReference VideoElement;
    private string? errorMessage;
    private bool processing = false;
    private bool isCameraStreaming;
    private string imageDataURL;
    private List<OCRService.ProcessResult> Histories=new List<OCRService.ProcessResult>();
    private OCRService.ProcessResult? result;
    private DotNetObjectReference<CameraScan>? objRef;
    [Inject]
    private OCRService _ocrService { get; set; } = null!;
    [CascadingParameter]
    private Task<AuthenticationState> AuthState { get; set; } = default!;
    private string currrentUser = "";
    private CameraScanJS? JsInterop; 
    protected override void OnInitialized()
    {
        objRef = DotNetObjectReference.Create(this);

    }
    public async ValueTask  DisposeAsync()
    {
        if (JsInterop != null)
        {
            await JsInterop.CameraOff();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            JsInterop =new  CameraScanJS(JS);
            await JsInterop.Init(VideoElement, objRef);
            currrentUser = (await AuthState).User.GetUserName();
        }
    }
    [JSInvokable]
    public void OnCameraStreaming(int innerWidth)
    {
        isCameraStreaming = true;
        if (this.innerWidth > innerWidth) this.innerWidth = innerWidth -4;
        StateHasChanged();
    }
    [JSInvokable]
    public async Task OnCaptureCallback(string data)
    {
        imageDataURL = data;
        var stream = saveBase64Image(data);
        result = await _ocrService.Process(stream,currrentUser).ConfigureAwait(true);
        processing = false;
        if (result.Entities.Persons is null)
        {
            Snackbar.Add($"The system is unable to identify the person. elapsed time:{result.ProcessingTime}" , MudBlazor.Severity.Error);
        }
        else
        {
            Snackbar.Add($"recognize person name {result.Entities.Persons.First()} elapsed time:{result.ProcessingTime}", MudBlazor.Severity.Info);
            Histories.Add(result);
            Histories.Reverse();
        }
        
        StateHasChanged();
    }
    private MemoryStream saveBase64Image(string base64Image)
    {
        string base64Data = base64Image.Substring(base64Image.IndexOf(',') + 1);
        byte[] imageBytes = Convert.FromBase64String(base64Data);
        return new MemoryStream(imageBytes);
    }
    private async Task Scan()
    {
        result = null;
        processing = true;
        if(JsInterop!=null)   await JsInterop.Capture(VideoElement, objRef);
    }
}
