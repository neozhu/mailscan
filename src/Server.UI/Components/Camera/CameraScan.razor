@using Services.JsInterop
@using Services
@inject IJSRuntime JS
<MudCard Style="width:390px">
    <div class="mud-card-media video-container" style="position: relative;width:390px;height:280px">
        <video id="video" @ref=VideoElement autoplay playsinline style="width:390px;height:273px;object-fit: cover;">
            @if (errorMessage is not null)
            {
                <div class="alert alert-danger">
                    @errorMessage
                </div>
            }
        </video>
        @if (processing)
        {
            <div class="blur-overlay" style="position: absolute; top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.5); /* 透明度可以调整 */
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);"></div>
        }
    </div>
    <MudCardActions Class="justify-space-between">
        <MudLoadingButton Loading="@processing" StartIcon="@Icons.Material.Filled.DocumentScanner" Variant="Variant.Filled" Disabled="@(!isCameraStreaming)" OnClick="Scan" Color="Color.Primary">Scan</MudLoadingButton>
        <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.ArrowBack">Previous</MudButton>
    </MudCardActions>
    <MudCardContent>
        @if (string.IsNullOrEmpty(result))
        {
            <MudSkeleton />
            <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="100px" />
        }
        else
        {
            <code>@result</code>
        }

    </MudCardContent>
    <MudCardMedia Image="@imageDataURL"></MudCardMedia>
</MudCard>

@code {
    private ElementReference VideoElement;
    private string? errorMessage;
    private bool processing = false;
    private bool isCameraStreaming;
    private string imageDataURL;
    private string result;
    private DotNetObjectReference<CameraScan>? objRef;
    [Inject]
    private OCRService _ocrService { get; set; } = null!;


    protected override void OnInitialized()
    {
        objRef = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await new CameraScanJS(JS).Init(VideoElement, objRef);
        }
    }
    [JSInvokable]
    public void OnCameraStreaming()
    {
        isCameraStreaming = true;
        StateHasChanged();
    }
    [JSInvokable]
    public async Task OnCaptureCallback(string data)      {        imageDataURL = data;        var stream = saveBase64Image(data);
        result = await _ocrService.Process(stream).ConfigureAwait(true);
        processing = false;
        StateHasChanged();
    }
    private MemoryStream saveBase64Image(string base64Image)
    {
        string base64Data = base64Image.Substring(base64Image.IndexOf(',') + 1);
        byte[] imageBytes = Convert.FromBase64String(base64Data);
        return new MemoryStream(imageBytes);
    }
    private async Task Scan()
    {
        result = "";
        processing = true;
        await new CameraScanJS(JS).Capture(VideoElement, objRef);
    }
}
